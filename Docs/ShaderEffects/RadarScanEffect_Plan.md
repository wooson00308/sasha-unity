# 레이더 스캔 효과 구현 계획 (셰이더 활용)

## 1. 최종 목표

-   레이더 UI의 회전하는 스캔 빔 애니메이션과 동기화되어, 스캔 빔이 통과하는 영역에 있는 유닛 마커들만 시각적으로 표시되도록 구현한다.
-   이를 통해 보다 현실감 있고 몰입도 높은 레이더 인터페이스를 제공한다.

## 2. 핵심 접근 방식

-   개별 유닛 마커(주로 이미지 컴포넌트)에 적용될 **커스텀 UI 셰이더**를 작성하여 사용한다.
-   마스크(Mask) 컴포넌트를 사용하지 않는 이유는, 레이더 전체가 회전하거나 이동할 때 마커도 함께 종속적으로 움직이는 것을 피하고, 각 마커가 월드 좌표 기반으로 독립적인 위치를 가지면서 스캔 효과만 받도록 하기 위함이다.

## 3. 필요 데이터 (셰이더 입력/유니폼 변수)

셰이더는 C# 스크립트로부터 다음 정보들을 실시간으로 전달받아야 한다:

-   `_RadarCenterUIPos` (Vector/float2): 레이더 UI 요소의 중심점 좌표. 마커의 상대적 위치 및 각도 계산의 기준점이 된다. (RectTransform의 월드 또는 로컬 좌표를 변환하여 사용)
-   `_ScanCurrentAngleRad` (float): 현재 레이더 스캔 빔의 중심 각도. 라디안 값으로 변환하여 전달하는 것이 삼각함수 연산에 유리하다. (레이더 오브젝트의 Z축 회전 값으로부터 계산)
-   `_ScanArcWidthRad` (float): 스캔 빔의 부채꼴 호 너비(각도). 라디안 값. (예: 30도 -> `30.0f * Mathf.Deg2Rad`)
-   `_FadeRangeRad` (float, 선택 사항): 스캔 빔의 가장자리에서 마커가 부드럽게 나타나고 사라지도록 하는 페이드(페더링) 효과를 위한 각도 범위. 라디안 값.

## 4. 셰이더 로직 개요 (HLSL/ShaderLab)

각 마커의 UI 이미지에 적용될 셰이더의 프래그먼트 셰이더(또는 서피스 셰이더의 일부)는 다음과 같은 로직을 수행한다:

1.  **현재 픽셀의 UI 좌표 가져오기**: 셰이더 내에서 현재 처리 중인 픽셀(프래그먼트)의 UI 공간 내 좌표를 얻는다. (UV 좌표 또는 스크린 좌표 활용)
2.  **레이더 중심 기준 상대 벡터 계산**: `현재 픽셀 UI 좌표 - _RadarCenterUIPos` 를 통해 레이더 중심에서 현재 픽셀을 향하는 2D 벡터를 계산한다.
3.  **상대 벡터의 각도 계산**: `atan2(상대벡터.y, 상대벡터.x)` 함수 등을 사용하여 위 벡터의 각도를 계산한다. 이 각도는 `_ScanCurrentAngleRad`와 비교될 기준이 된다. (Unity의 UI는 일반적으로 Y축이 위쪽이므로 `atan2`의 파라미터 순서에 유의)
4.  **스캔 범위 내 판정**:
    -   계산된 픽셀 각도가 `_ScanCurrentAngleRad` 를 중심으로 `_ScanArcWidthRad / 2` 범위 내에 있는지 확인한다.
    -   각도 비교 시, 각도가 0/360도를 넘어가는 순환(wrapping) 처리를 고려해야 한다. (예: `deltaAngle = Mathf.DeltaAngle` 과 유사한 로직 필요)
5.  **알파 값 결정**:
    -   픽셀이 스캔 범위 내에 있다면, 마커의 원래 텍스처 색상과 알파 값을 사용한다.
    -   `_FadeRangeRad` 가 설정되어 있다면, 범위 가장자리에서 알파 값을 0에서 1로 (또는 그 반대로) 부드럽게 변경한다 (`smoothstep` 함수 활용).
    -   픽셀이 스캔 범위 밖에 있다면, 최종 알파 값을 0으로 설정하여 보이지 않게 한다.
6.  **최종 색상 출력**: 계산된 알파 값을 포함하여 최종 픽셀 색상을 출력한다.

## 5. C# 스크립트 연동 (`CombatRadarUIService.cs` 또는 전용 컨트롤러)

-   `CombatRadarUIService` (또는 레이더 애니메이션 정보를 셰이더로 전달할 책임이 있는 스크립트)는 다음을 수행한다:
    -   애니메이션 클립에 의해 Z축이 회전하는 레이더 UI 오브젝트의 `Transform` (또는 `RectTransform`) 참조를 가진다.
    -   스크립트의 `LateUpdate()` 메서드 내에서 다음을 수행한다. (`LateUpdate`를 사용하는 이유는 애니메이션 시스템이 해당 프레임의 Transform 업데이트를 완료한 이후의 값을 읽기 위함이다):
        1.  참조하고 있는 레이더 오브젝트의 현재 Z축 회전 값 (`transform.eulerAngles.z` 또는 `rectTransform.localEulerAngles.z`)을 가져온다.
        2.  이 회전 각도를 라디안으로 변환하여 셰이더 유니폼 변수 `_ScanCurrentAngleRad` 로 사용한다. (Unity의 오일러 각은 0-360 범위이므로, 셰이더에서 음수 각도 또는 특정 범위의 각도가 필요하다면 추가 변환이 필요할 수 있다. 일반적으로 `atan2`의 결과와 일치시키려면 Y축이 위로 향하는 좌표계에서 각도를 계산하는 것이 일관적이다.)
        3.  인스펙터 등에서 설정된 스캔 빔의 너비 (`_ScanArcWidth`)와 페이드 범위 (`_FadeRange`) 값을 도(degree)에서 라디안으로 변환한다.
        4.  레이더 UI 요소의 중심 좌표를 계산하여 `_RadarCenterUIPos` 로 전달한다. (캔버스 스케일 모드 및 앵커/피봇 설정에 따라 `RectTransformUtility` 사용 또는 직접 계산이 필요할 수 있다.)
        5.  레이더에 표시되는 모든 유닛 마커들이 사용하는 머티리얼(들)에 위에서 준비된 유니폼 변수들을 `Material.SetFloat()` 또는 `Material.SetVector()` 등을 사용하여 업데이트한다.
            -   모든 마커가 동일한 머티리얼 인스턴스를 공유하고 있다면 해당 머티리얼에 한 번만 값을 설정한다.
            -   성능이 중요하다면, 마커가 매우 많을 경우 각 마커의 `Renderer`에 `MaterialPropertyBlock`을 설정하는 방식을 고려할 수 있으나, UI 요소에 직접 적용하기는 복잡할 수 있다. UI에서는 일반적으로 머티리얼 공유가 권장된다.

## 6. 추가 고려 사항

-   **좌표계**: Unity UI (캔버스) 좌표계, 스크린 좌표계, 셰이더 내에서의 좌표계 간 변환에 주의한다.
-   **셰이더 종류**: UI 요소에 적합한 Unlit 셰이더를 기반으로 작성하거나, Unity UI 시스템과 호환되는 커스텀 버텍스/프래그먼트 셰이더를 작성한다. URP/HDRP 환경이라면 해당 파이프라인에 맞는 UI 셰이더 템플릿을 고려한다.
-   **최적화**:
    -   셰이더 연산은 가능한 한 단순하게 유지한다.
    -   많은 수의 마커가 있을 경우, 각 마커마다 `Material.SetFloat`를 호출하는 것보다 `Shader.SetGlobalFloat`를 사용하거나, `MaterialPropertyBlock`을 활용하는 것이 더 효율적일 수 있다. (단, `MaterialPropertyBlock`은 UI 요소에 직접 적용하기 까다로울 수 있음)
-   **레이더 빔 자체의 시각화**: 이 계획은 마커의 표시에 초점을 맞춘다. 레이더 빔(부채꼴 스윕) 자체의 시각화는 별도의 이미지와 애니메이션, 또는 또 다른 셰이더로 구현될 수 있으며, `_ScanCurrentAngleRad`와 `_ScanArcWidthRad` 값을 공유하여 동기화할 수 있다. 